## 表相关
---
MyISAM 是 Mysql 的默认存储引擎。

##  Heap 表是什么？⭐ :id=heap
HEAP 表存在于内存中，用于临时高速存储。
1. BLOB 或 TEXT 字段是不允许的
1. 只能使用比较运算符=，<，>，=>，= <
1. HEAP 表不支持 AUTO_INCREMENT
1. 索引不可为 NULL

## 如何控制 HEAP 表的最大尺寸? ⭐⭐ :id=heap-max
Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量

## 主键和候选键有什么区别？⭐ :id=key-main
表格的每一行都由主键唯一标识,一个表只有一个主键。
主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

## federated 表是什么？⭐ :id=federated
federated 表，允许访问位于其他服务器数据库上的表。

## 列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？⭐ :id=atuo-increment
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

## 解释访问控制列表? ⭐ :id=acl
ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基
础，它有助于排除用户无法连接的问题。
Mysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql 会
按照预定的顺序检查 ACL 的认证信息和权限。

## MYSQL 数据表在什么情况下容易损坏？⭐ :id=table-damage
1. 服务器突然断电导致数据文件损坏。
1. 强制关机，没有先关闭 mysql 服务等。

## mysql 有关权限的表都有哪几个？⭐ :id=acl-table
Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由
mysql_install_db 脚本初始化。这些权限表分别 
1. user
2. db
3. table_priv
4. columns_priv
5. host

## MySQL分表分库全局ID? ⭐⭐⭐⭐ :id=party-table
mysql分库分表确实能解决不少问题，也能让数据库支撑更大的并发、大数据量业务, 可是分库分表后必然面对的f 问题就是id咋生成？ id生成后如何保持全局唯一

**数据库自增id**

系统里每次得到一个id,都是往一个库的f旌插入一条没什么业务含义的数据，然 后获取 f 数据库自增的 fid。拿到这个id之后再往对应的分库分表里去写入。这样 确实可以解决，但是在高并发业务场景下，就会发生瓶颈，瞬间那一刻会出现脏数据。 所以这个办法只能适合非高并发下的分表分库，如何生成全局id。

**uuid**

本地成，格基于数据库来了；不好之倾是，uuid太长了，作为主键性能太差了， 不适合用于主键。
如果你是要随机生成个什么文件名了，编号之类的，你可以用uuid,但是作为主键是不 能用uuid的。

**获取当前系统时间**

这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有 重复的情况，这个是肯定不合适的。
一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个id,如 果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接 起来，组成一^局唯一的标识，订单号，时间戳+用户id +业务唯一标识。

**snowflake 算法**

在系统小时，唯一标识的产生，可以利用公用模块来处理，比如数据库表的唯一键、或 者缓存的唯一 id等等方式。但在分布式高并发的系统中，如果还是这样使用公共模块， 就会产生彳耿的风蜿瓶颈。
snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想 是：使用41 bit作为毫秒数，10 bit作为机器的ID （5个bit是数据中心，5个bit的机器 ID） , 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生4096个ID）,最 后还有T符号位，永远是0。
这个算法单机每秒内理论上最多可以生成1000（2^12）,也就是409.6万个ID,（吼 吼，这个得了的快啊）.

相关Java实现代码：

https://www.cnblogs.eom/relucent/p/4955340.html

综上所述，也基本是笔者自己去面试大厂，或者自己作为面试官招聘高工、资深时都会 问的问题，上述比如全局id很多人都没怎么去了解过、mysql锁很多人更蹒意识等， 希望通过一W可题能让读者可以学习到一点知识。