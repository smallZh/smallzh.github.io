## 锁相关题目
---
## MySQL中控制并发的方式有哪些？⭐⭐⭐ :id=concurrent
并发控制一般采用三种方法，分别是：
1. 乐观锁
2. 悲观锁
3. 时间戳

## 说一下乐观锁？⭐⭐⭐ :id=hopeful-lock
乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
戳就是不加锁，通过时间戳来控制并发出现的问题。

## 说一下悲观锁？⭐⭐⭐ :id=pessimism-lock
悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
许其他用户访问那部分数据。

## 说一下时间戳如何控制并发？⭐⭐⭐ :id=time-lock
时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁
机制，但是这种方法可以大大提高数据库处理的并发量，

以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。

## 说一下行级锁？⭐⭐⭐ :id=line-lock
行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：
1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
3. 使用 COMMIT 或 ROLLBACK 语句释放锁。

## 说一下表级锁？⭐⭐⭐ :id=table-lock
表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使
用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
（排他锁）。

## 说一下页级锁？⭐⭐⭐ :id=page-lock
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁。

## 说一下基于Redis分布式锁？⭐⭐⭐ :id=redis-dist-lock
1. 获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。
2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。

## Mysql 中有哪几种锁？⭐ :id=lock-type
MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
1. 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最
低
1. 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最搞

## MySQL数据库锁? ⭐⭐⭐ :id=lock-tenet
面试官一般聊锁，就是问myisam和innodb存储弓|擎下的表锁、行锁，还有可能想知道 死锁咋办，如何检测业务中锁。

**mysql 锁**

—般myisam会加表锁，就是myisam引擎下，执彳的时候，会默讷口个表共享锁， 也就是表读锁，这个时候别人只能来查，不能写数据的；然后myisam写的时候，也会 加个表独占锁,也就是表写锁，别人不能读稣能孔丄I 这个myisam因为很少用了，面试的时候大致说下就可以啦。其实很多人也发现了， myisam其实在实际生产中，也就新闻资讯、报表系统等，也就是纯粹读写比，读超级多 的系统在用了，压根不涉及事务。可以简单理解为olap业务。
innodb的行锁有共享锁 ⑸ 和排他锁（X）,两种，其实说白了呢，共享锁就是，多个 事务都可颇共享锁读同一行数据，但是别的事务不能写这行数据；排他锁，就是就一 个事务可以写这行数据，别的事务只能读，不能写。
innodb的表锁，分成意向共享锁，就是说加共享行锁的时候，必须先加这个共享表锁； 还有一个意向排他锁，就是说，给某行加排他锁的时候，必须先给表加排他锁。这个表 锁，是innodb引擎自动加的，不用你自己去加。
insert、叩date、delete, innodb会自动给那—行加行级排他锁。
select, innodb啥锁都不加，因为innodb默认实现了可重复读，也就是mvcc机制，所 以多个事务随便读f 数据，一般不会有冲突，大鏡读自己那个快照就可以了，不涉 及到什么锁的问题。但是innodb从来不会自己主动加个共享锁的，除非你用下面的语句 自己手动加个锁：
・手动加共享锁： select * fro m table where id=xxx lock in share mode ,那你就给那一行加了个共享锁，其他事务就不能来修改这行数据了.

•手动加排他锁：select * from table where id=xxx for update ,那你就给 那一行加了个排他锁，意思就是你准备修改，另啲事务就别修改了，另啲事务的修 改会卡住。这个要慎用，一蟀上系统禁止使用。

**死锁场景**

—个 client 下:
session a： select * from car where id=l for update session b:select * from car where id=2 for update
另外一个client下:
session a： select * from car where id=2 for update session b:select * from car where -id=l for update
如此上述场景就会导致死锁，可以根据i nnodb_lock_waits innodb_locks等查询 具体是那些sql导致，具体分析下。