## 二叉树相关问题
---
## 什么是二叉树？ ⭐⭐⭐ :id=b_tree
满足以下两个条件的树就是二叉树：
1. 本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）；
1. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

简单地理解，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。

![](../imgs/b_tree_1.jpg)

## 二叉树查找？ ⭐⭐⭐ :id=b_tree_search
维基百科上的定义：
> 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树。

若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；任意节点的左、右子树也分别为二叉查找树。

图解：

![](../imgs/b_tree_search.gif)

假定，我们以查找29为例：
1. 查看根节点 41。
1. 因为 41>29，所以查看 41 的左子树节点 20。
1. 因为 20<29，所以查看 20 的右子树节点 29，发现其正好是要查看的节点。

## 如何理解二叉树的退化？ ⭐⭐⭐ :id=b_tree_dge
二叉查找树有个非常严重的问题，如果数据的插入是从大到小插入的，或者是从小到大插入的话，会导致二叉查找树退化成单链表的形式，俗称瘸子。

**左瘸子：**

例如，插入数据依次为 {5,4,3,2,1}（从大到小），则如下图所示：

![](../imgs/b_tree_dge_1.gif)

**右瘸子：**

例如，插入数据依次为{1,2,3,4,5}（从小到大），则如下图所示：

![](../imgs/b_tree_dge_2.gif)

采用平衡树解决该问题

## 什么是平衡树？ ⭐⭐⭐ :id=bal_tree
平衡树（Balance Tree，BT）指的是
> 任意节点的子树的高度差都小于等于 1。

常见的符合平衡树的有 
1. AVL 树（二叉平衡搜索树）
2. B 树（多路平衡搜索树，2-3 树，2-3-4 树中的一种）
3. 红黑树

## 什么是AVL树？ ⭐⭐⭐ :id=avl
AVL 树（由发明者 Adelson-Velsky 和 Landis 的首字母缩写命名），是指
> 任意节点的两个子树的高度差不超过 1 的平衡树。
> 又称自平衡二叉搜索树。

AVL 树能解决上文二叉查找树中的右瘸子问题，例如，插入数据依次为 {1,2,3,4,5}（从小到大），则如下图所示：

![](../imgs/avl.gif)

AVL 树会对不符合高度差的结构进行调整，从而使得二叉树趋向平衡

## 理解 2-3树？ ⭐⭐⭐ :id=2-3-tree
2-3 树，是指每个具有子节点的节点（内部节点，internal node）要么有两个子节点和一个数据元素，要么有三个子节点和两个数据元素的自平衡的树，它的所有叶子节点都具有相同的高度。

简单点讲，2-3 树的非叶子节点都具有两个分叉或者三个分叉，所以，称作 2 叉-3 叉树更容易理解。

另外一种说法，具有两个子节点和一个数据元素的节点又称作 2 节点，具有三个子节点和两个数据元素的节点又称作 3 节点，所以，整颗树叫做 2-3 树。

![](../imgs/2_3_tree.jpg)

所有叶子点都在树的同一层，一样高：
1. 性质 1：满足二叉搜索树的性质。
1. 性质 2：节点可以存放一个或两个元素。
1. 性质 3：每个节点有两个或三个子节点。

## 如何创建2-3树？ ⭐⭐⭐ :id=2-3-tree-create
**向 2-节点中插入元素：**

![](../imgs/2_3_tree_1.jpg)

**向 3-节点的树中插入元素：**

![](../imgs/2_3_tree_2.jpg)

## 如何理解2-3-4树？ ⭐⭐⭐ :id=2-3-4-tree
含义如下：
1. 2 节点：包含两个子节点和一个数据元素。
1. 3 节点：包含三个子节点和一个数据元素。
1. 4 节点：包含四个子节点和一个数据元素。

![](../imgs/2_3_4_tree.jpg)

2-3-4 树，它的每个非叶子节点，要么是 2 节点，要么是 3 节点，要么是 4 节点，且可以自平衡，所以称作 2-3-4 树。

规则如下：
> 1. 规则 1：加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上。
> 1. 规则 2：四节点可以被分解三个 **2-节点** 组成的树，并且分解后新树的根节点需要向上和父节点融合。

我们看一个插入操作：

假如 最开始的 2-3-4树 如下：

![](../imgs/2_3_4_tree_1.jpg)

接下来，我们插入一个 `17`节点 ，根据规则 1，节点 17 不会加入节点 [16,18,20] 的子树，而是与该节点融合。如下：

![](../imgs/2_3_4_tree_2.jpg)

此时，根据规则 2，节点 [16,17,18,20] 是一个 4 节点，将该节点进行拆解成新的树，将 18 作为子树的根节点进行拆分。如下：

![](../imgs/2_3_4_tree_3.jpg)

此时，树暂时失去了平衡，我们需要将拆分后的子树的根节点向上进行融合。如下：

![](../imgs/2_3_4_tree_4.jpg)

此时，对于跟节点，也是一个 4节点，根据规则 2，将根节点进行拆解成新的树，将 14 作为子树的根节点进行拆分，完成了 2-3-4 树的构建。如下：

![](../imgs/2_3_4_tree_5.png)

总结了下插入节点的过程，无非也就为了符合两条规则，那么，2-3 树，2-3-4 树都有了，那是不是也有 2-3-4-5 树，2-3-4-5--...-n 树的存在呢？

事实上是有的，世人把这一类树称为一个名字：B 树。

## 怎么理解 B树？⭐⭐⭐⭐ :id=b-tree
B 树，表示的是一类树，它允许一个节点可以有多于两个子节点，同时，也是自平衡的，叶子节点的高度都是相同的。

所以，为了更好地区分一颗 B 树到底属于哪一类树，我们给它一个新的属性：度（Degree）：一个节点能有多少箭头指向其他节点。

具有度为 3 的 B 树，表示一个节点最多有三个子节点，也就是 2-3 树的定义。具有度为 4 的 B 树，表示一个节点最多有四个子节点，也就是 2-3-4 树的定义。

图为 4 的 B 树的示例图：

![](../imgs/2_3_4_tree_1.jpg)

## 怎么理解 红黑树？ ⭐⭐⭐⭐ :id=r-b-tree
R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。

红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）。

![](../imgs/r_b.png)

![](../imgs/r_b_1.jpg)

同 之前的 2-3-4树比较，如下：

![](../imgs/rb_vs_234.png)

可以说，红黑树就是一种 2-3-4树，也是 一种 B树，只不过 有两个节点

## 说一下 红黑树的特性？ ⭐⭐⭐⭐ :id=r-b-tree-metric
1. 每个节点或者是黑色，或者是红色。
1. **根节点是黑色**。
1. **每个叶子节点（NIL）是黑色**。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
1. 如果一个节点是红色的，则它的子节点必须是黑色的。由于红黑树的每个节点都是由2-3-4树转化而来的，从而红色节点不能连续两个出现，不然会出现4节点的情况，导致违反了规则2。而且红黑树的每一个黑节点都是3节点中的最中间的那个值，或者是2节点中其中一个值。
1. **从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点**。

**特性4的原因：**

红黑树这些黑色节点在 2-3-4 树中代表的是由 1 节点的一个 2-3-4 树，而 2-3-4 树是同一个子树的深度是相同的，平衡的，所以从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

如下图所示，蓝色代表是黑色节点：

![](../imgs/rb_3.jpg)

注意如下几点：
1. 特性（3）中的叶子节点，是只为空（NIL 或 null）的节点。
1. 特性（5），确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。
1. 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为 O(log n)。

由上面的例子所示，我们只要把红黑树当做是 2-3-4 树来处理，并且对应的颜色进行改变或者进行左旋右旋的操作，即可达到使得红黑树平衡的目标。

## 如何保持红黑树的结构 ⭐⭐⭐⭐⭐ :id=r-b-tree-create
当我们插入一个新的节点的时候，如何保证红黑树的结构依然能够符合上面的五个特性呢？

树的旋转分为**左旋**和**右旋**，下面借助图来介绍一下左旋和右旋这两种操作。

**左旋**

假定一个树原本的状态如下：

![](../imgs/rb_c.jpg)

过程如下：

![](../imgs/rb_c.gif)

结束后：

![](../imgs/rb_c.png)

如上图所示，当在某个目标结点 E 上，做左旋操作时，我们假设它的右孩子 S 不是 NIL。

左旋以 S 到 E 之间的链为“支轴”进行，它使 S 成为该子树的新根，而 S 的左孩子则成为 E 的右孩子。

**右旋**

假定树的原本状态为：

![](../imgs/rb_c1.png)

过程如下：

![](../imgs/rb_c1.gif)

结束后：

![](../imgs/rb_c1.jpg)

同左旋类似，当在某个目标结点 S 上，做右旋操作时，我们假设它的右孩子 S 不是 NIL。

左旋以 S 到 E 之间的链为“支轴”进行，它使 S 成为该子树的新根，而 S 的左孩子则成为 E 的右孩子。

## 红黑树有哪些场景？ ⭐ :id=r-b-tree-secen
红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是 O(logn)，效率非常之高。

例如，Java 集合中的 TreeSet 和 TreeMap，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的。