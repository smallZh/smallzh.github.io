## 泛型相关
---
## 1 解释一下Java中的泛型？⭐ :id=java-generic
泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本
质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，
能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。

## 说一下Java的泛型方法？⭐ :id=java-generic-method
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。

1. \<? extends T>表示该通配符所代表的类型是 T 类型的子类。
2. \<? super T>表示该通配符所代表的类型是 T 类型的父类。

```java
// 泛型方法 printArray 
public static \< E > void printArray( E[] inputArray ){ 
 for ( E element : inputArray ){ 
 	System.out.printf( "%s ", element );
 }
}
```

## 解释一下Java的泛型类？⭐ :id=generic-class
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一
样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，
也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，
这些类被称为参数化的类或参数化的类型。

```java
public class Box<T> {
 private T t;
 public void add(T t) {
 this.t = t;
 }
 public T get() {
 return t;
 }
```

## 类型通配符? ⭐ :id=common-lit
类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List\<?> 在逻辑上是List\<String>,List\<Integer> 等所有 List\<具体类型实参>的父类。

## 类型擦除? ⭐ :id=type-remove
Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List\<Object>和 List\<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。

类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。
